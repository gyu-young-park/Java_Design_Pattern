브리지 패턴

이 패턴은 많이 사용되는 것은 아니고, 잠깐 잠깐 사용되는데, 어댑터 패턴이랑 비슷하다.

브릿지 패턴
"구현(implementation)으로부터 추상(abstraction) 레이어를 분리하여 이 둘이 서로 독립적으로 변화할 수 있도록 한다."
"구현부에서 추상층을 분리하여 각자 독립적으로 변형이 가능하고 확장이 가능하도록 한다.

즉 기능과 구현에 대해서 두 개를 별도의 클래스로 구현을 한다."
"두개의 다른 계층(하나는 추상, 하나는 구현인 서로다른 계층의 커플링을 약화시키며 협력은 가능하도록 하는 패턴"
출처: https://www.crocus.co.kr/1537 [Crocus]

-학습 목표
    브릿지 패턴을 이해한다.
    어댑터 패턴과 브릿지 패턴을 연결하여 이해한다.

키워드
    기능과 구현의 분리

기본 설계

기능(추상 부분) - 구현 부분

추상적으로 어떤 기능을 사용하겠다. 물론 여기서 기본적인 기능도 있다.
이 추상 기능으로 또 다른 추상 클래스를 만들 수 있다.
추상 기능의 구현은 구현 클래스를 따로 둔다.

이는 추상 클래스 안에 맴버 변수로 구현 클래스를 가지고 있어서
그 맴버 변수로 추상 클래스 안에서 구현을 기능하는 것이다.

-실습
오늘은 모스부호 기능을 구현해보자
규칙: 모스부호는 대쉬, 닷이 있다. + space

모스 부호 코드를 상속 받는 클래스 PrintMorseCode 를 만들어주자

그런데, 나중에  - . 말고 다른 걸로 바꾸어주게 해야한다면??
예를 들어 비프음으로 바꾸게 해야한다면
package com.company;

public class MorseCode {
    public void dot(){
        ^^System.out.print(".");

    }
    public void dash(){
        ^^System.out.print("-");
    }
    public void space(){
        ^^System.out.print(" ");
    }
}
^^표시된 부분들의 코드를 다 바꾸어주던지 새로운 클래스를 만들어주어야한다.
만약 새로운 클래스인 MorseCode2를 만들면 또 새로운 PrintMorseCode2도 만들던지,
아니면 상속을 새로 받아야한다.

그래서, 기능과 구현의 분리를 하도록 하자,


public class MorseCode {
    public void dot(){
        ^^System.out.print(".");

    }
    public void dash(){
        ^^System.out.print("-");
    }
    public void space(){
        ^^System.out.print(" ");
    }
}

^^부분을 다른 부분에서 구현하도록 하는 것이다.

그래서 브릿지 패턴을 사용하면
MorseCode라는 클래스가 모스 부호에 대한 기본적인 규칙들을 담고 있고
PrintMorseCode는 MorseCode에서 구현된 메서드를 이용해서 모스 기호로 알파벳을 호출하는 클래스이다.
여기서, 만약, 모스 부호의 규칙이 바뀐다면, 즉, DOT SPACE DASH가 아니라, 닷, 공백 , 대쉬라는 문자로 출력을 하던지 또는 소리로 삐- 삐삑- 삐이- 로 나게 바꾸고 싶다면,
MorseCode 부분을 다 바꾸어 주어야하는 문제가 생긴다.
기존에 잘 돌아가던 코드를 굳이 바꿀 필요는 없으므로 추상적인 기능만 하는 인터페이스를 하나만들어준다.
MorseCode에 맴버 변수로 MorseCodeRootFunc 이라는 인터페이스를 넣어주자
그리고 이에 대한 구현체를 구현해준다. DefaultMorseCode와 SoundMorseCode 등을 만들어주고, 추가로 필요한 구현체들이 나오면 구현체들만 만들어주면 된다.
그리고 MorseCode에서는 해당 추상 클래스의 기능 선언 부분만을 이용해서 자신이 원하는 기능을 쓰면 된다.
필요한 구현체들이 달라질 때마다 다리를 바꾸듯이 맴버 변수 MorseCodeRootFunc의 구현체들만 바꾸면 다른 기능이 되기 때문이다.

우리는 기능 부분만 바꾼 것이다.
우리가 직접 사용하는 부분들은 건들지 않았으므로 복잡도가 낮아진다.

어댑터 디자인 패턴 vs 브릿지 디자인 패턴

두 패턴 모두 Interface의 detail을 감추고자 하며, 구조적인 차이가 없다.
하지만 두 패턴은 서로 사용하고자 하는 목적의 차이가 분명하다.
- 어댑터는 어떤 클래스의 인터페이스가 다른 코드에서 기대하는 것과 다를 때(기능은 같은 데, 함수명이 다를 때) 어댑터를 중간에 두어 맞춰주는 것이다.
- 브릿지는 추상과 구현을 분리하는 것이다.(추상 클래스는 추상 클래스 대로, 구현은 구현 대로 변경해도 서로 영향을 주지 않도록 한다.)
- 어댑터는 결국 어떤 코드에 맞게끔 기존의 코드를 쓰기 위해 사용되고, 브릿지는 확장성을 고려하여 미리 예상하여 bridge class를 구현해 코드 작성시 사용되어진다.

즉 어댑터 패턴은 기존에 있는 구현(!!!) 부분을 어댑터를 두어 내가 원하는 부분으로 바꾸어 주는데, 문제는 기존에 있는 해당 구현 부분을 사용하면서 바꾼다는 점이다.
예를 들어 기존 구현 부분이 math라는 메서드를 가지고 잇는데 반환형이 float이라면, 내가 어댑터를 두어 math라는 메서드를 사용해 결과를 더블로 바꾸어 주는 것이다.
반면 브릿지는 기존에 있는 구현 부분을 바꾸어주는 것이다. 즉, math라는 메서드를 사용하지 않는 다른 구현체를 가져와 사용하는 것이다. 이러한 부분이 가능한 이유는
브릿지 패턴은 구현과 추상 계층간의 분리를 통해서 다형성을 이용한 기능의 선언을 이용해, 마음대로 구현체를 바꿀 수 있기 때문이다.

전략 패턴 vs 브릿지 패턴
-굉장히 닮았다.
전략 패턴은 구현부의 잦은 교체를 생각하는 패턴이라면
브릿지 패턴은 계층간의 의존성을 낮추는 데에 목적이 있다.

두 패턴이 닮았지만, 이들의 목적이 다르다. 전략 패턴은 잦은 구현 부분의 교체를 추상화하여 변경 가능하도록 만드는 목적이고,
브릿짓 패턴은 추상과 구현을 분리시켜 두 계층 간의 의존성을 갖추는데에 있다.

즉, 해당 예제에서는 모스 기호로 'garam'을 표현하는 것이 있었는데, 이 'garam'을 표현하는 방식으로 . - 과 닷, 대쉬 와 삐, 삐삑 등이 있는 것이다.
이 들 중에 아무거나 사용해도 되는 것이다.

그런데, 전략 패턴은 다르다. 전략 패턴은 공격을 사용해야하는데, 내가 가진 무기가 도끼라서 도끼 소리인 쿵! 소리가 나는 것이다.
내가 공격이라는 메서드를 실행하기 위해서 무기들을 아무거나 써도 되는 것이 이나라, 딱 정해진 무기를 사용해야만 하는 것이다,

전략 패턴은 책상의 풀려버린 나사를 쪼이기 위해 딱 맞는 드라이버를 가져오는 것이고
브릿지 패턴은 이메일을 작성할 것인데 아이패드냐 pc냐, 갤럭시 탭이냐와 같은 것이다.
